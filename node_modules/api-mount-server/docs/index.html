<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>api-mount-server</title>
	<meta name="description" content="Documentation for api-mount-server">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">api-mount-server</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>api-mount-server</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#api-mount-server" id="api-mount-server" style="color: inherit; text-decoration: none;">
					<h1>api-mount-server</h1>
				</a>
				<p><em>by Vytenis Urbonaviƒçius</em></p>
				<p><em>api-mount-server</em> library provides a straightforward way of exposing API from a Node.js server application for consumption on a client side using <a href="http://npmjs.com/package/api-mount-client">api-mount-client</a> library.</p>
				<hr>
				<a href="#installation" id="installation" style="color: inherit; text-decoration: none;">
					<h2>Installation</h2>
				</a>
				<p>Consider using a more universal library - <a href="http://npmjs.com/package/api-mount">api-mount</a>. <em>api-mount</em> contains both server and client code in one package. Usage and available methods are identical to <em>api-mount-server</em>. Only package name differs.</p>
				<p>If you want to continue using a server-only version:</p>
				<pre><code>npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save api-mount-server</span></code></pre>
				<a href="#usage" id="usage" style="color: inherit; text-decoration: none;">
					<h2>Usage</h2>
				</a>
				<a href="#constructing-api-objects" id="constructing-api-objects" style="color: inherit; text-decoration: none;">
					<h3>Constructing API objects</h3>
				</a>
				<hr>
				<p>This library allows exposing API objects. These objects can be constructed in multiple ways.</p>
				<p>Simple object with methods:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> api = {
  foo() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>
  },
}</code></pre>
				<p>Set of functions collected into an API object:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// api.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;foo&#x27;</span></code></pre>
				<pre><code class="language-typescript"><span class="hljs-comment">// mount.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> api <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./api&#x27;</span>
<span class="hljs-comment">// ...</span></code></pre>
				<p>Object created from a class</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">class</span> SomeClass {
  foo() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>
  }
}

<span class="hljs-keyword">const</span> api = <span class="hljs-keyword">new</span> SomeClass()</code></pre>
				<p>Static class (if supported)</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">class</span> StaticClass {
  <span class="hljs-keyword">static</span> foo() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>
  }
}</code></pre>
				<p>There may be more ways but these are just a few examples to showcase the possibilities.</p>
				<a href="#writing-api-methods" id="writing-api-methods" style="color: inherit; text-decoration: none;">
					<h3>Writing API methods</h3>
				</a>
				<hr>
				<p>API methods are normal methods or functions with one constraint - they can only operate with serializable values (arguments, return value). In this case serializable value is a value which can be converted into <em>JSON</em> using <em>JSON.stringify()</em> method.</p>
				<p>In addition to the rule above, API may be asynchronous - it may return a <em>Promise</em> if needed. It can also throw an exception.</p>
				<p>Asynchronous API function example:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// Using timer to simulate asynchronous behavior</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-string">&#x27;foo&#x27;</span>), <span class="hljs-number">1000</span>))</code></pre>
				<p>Synchronous API function example:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;foo&#x27;</span></code></pre>
				<p>Please note that even when synchronous API is used, client will see these return values as promises which can be extracted either with <em>.then</em> or with <em>async</em> keyword:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// ...</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> API.foo()) <span class="hljs-comment">// &#x27;foo&#x27;</span>

<span class="hljs-comment">// or</span>

API.foo().then(<span class="hljs-built_in">console</span>.log) <span class="hljs-comment">// &#x27;foo&#x27;</span>

<span class="hljs-comment">// ...</span></code></pre>
				<p>You can find more information about how API can be accessed from client side here: <a href="http://npmjs.com/package/api-mount-client">api-mount-client</a></p>
				<a href="#exposing-api-object" id="exposing-api-object" style="color: inherit; text-decoration: none;">
					<h3>Exposing API object</h3>
				</a>
				<hr>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> {apiMountFactory} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;api-mount-server&#x27;</span>

<span class="hljs-keyword">const</span> api = {
  <span class="hljs-comment">/* ... API methods ... */</span>
}

<span class="hljs-keyword">const</span> ApiMount = apiMountFactory()
ApiMount.exposeApi(api)</code></pre>
				<p>When exposing non-class-based objects, one needs to be aware that API will not be namespaced by default. In other words, <em>foo</em> will be accessible via HTTP directly as:</p>
				<pre><code>  <span class="hljs-string">/foo</span></code></pre><p>This may cause trouble when exposing multiple APIs - name clashes can cause trouble, also api methods from several API objects may be fused together into a single API object from the perspective of a client.</p>
				<p>One possible solution is to provide namespaces manually like this:</p>
				<pre><code class="language-typescript">ApiMount.exposeApi(api, {basePath: <span class="hljs-string">&#x27;/some-namespace&#x27;</span>})</code></pre>
				<p>There is also an easier way for those who prefer using classes. Namespaces are added automatically when using <em>exposeClassBasedApi</em>:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">class</span> SomeClass {
  foo() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>
  }
}

ApiMount.exposeClassBasedApi(<span class="hljs-keyword">new</span> SomeClass())</code></pre>
				<p>In this case <em>foo</em> will become available via HTTP as:</p>
				<pre><code>/some-<span class="hljs-keyword">class</span>/<span class="hljs-symbol">foo</span></code></pre><p>If one uses configuration which supports static classes (i.e. TypeScript), following approach can be used:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">class</span> StaticClass {
  <span class="hljs-keyword">static</span> foo() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>
  }
}

ApiMount.exposeClassBasedApi(StaticClass)</code></pre>
				<p>In this case <em>foo</em> will become accessible via HTTP as:</p>
				<pre><code>/<span class="hljs-keyword">static</span>-<span class="hljs-class"><span class="hljs-keyword">class</span>/<span class="hljs-title">foo</span></span></code></pre>
				<a href="#cors" id="cors" style="color: inherit; text-decoration: none;">
					<h3>CORS</h3>
				</a>
				<hr>
				<p>One common problem when starting to use <em>api-mount-server</em> is that requests are blocked by browser&#39;s CORS policy. Depending on client configuration symptoms may be either completely blocked requests or opaque responses (i.e. missing response information).</p>
				<p>There are multiple ways to solve this problem like serving from same domain as client, using proxies, etc. However, one of the quickest solutions/workarounds is using <em>cors</em> npm package when serving API to state that cross-domain requests should be accepted:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> ApiMount = apiMountFactory({
  beforeListen: <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> {
    <span class="hljs-comment">// This is just for testing purposes</span>
    <span class="hljs-comment">// You would probably want to explicitly list</span>
    <span class="hljs-comment">// where you expect requests to be coming from</span>
    <span class="hljs-comment">// for security reasons</span>
    app.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)())
  },
})
<span class="hljs-comment">// ...</span></code></pre>
				<a href="#supported-configuration" id="supported-configuration" style="color: inherit; text-decoration: none;">
					<h2>Supported Configuration</h2>
				</a>
				<p>As one could see in the above examples, it is possible to pass configuration object which alters behavior of <em>api-mount</em>. All these methods accept configuration object as (last) argument:</p>
				<ul>
					<li>apiMountFactory</li>
					<li>exposeClassBasedApi</li>
					<li>exposeApi</li>
				</ul>
				<p>Configuration object may contain following keys:</p>
				<ul>
					<li>name - express app name - only needed in corner case when there are several express apps initialized manually at the same time (using <em>injectLaunchCode</em>).</li>
					<li>basePath - path to be added to HTTP address before automatically generated part. Mostly useful for name-spacing.</li>
					<li>beforeListen - hook for altering Express configuration. It is very useful for things like CORS configuration, etc. This hook will not fire nor it is needed if custom launch code is injected.</li>
					<li>beforeExecution - hook for injecting logic before handling api request.</li>
					<li>beforeResponse - hook for customizing server response logic.</li>
					<li>afterResponse - hook for injecting logic after server responds.</li>
					<li>port - server port number - only available when calling <em>apiMountFactory</em>.</li>
				</ul>
				<p>Should one want to customize how <em>express</em> app is initialized, this is how it can be done:</p>
				<pre><code class="language-typescript">injectLaunchCode(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> newApp = express()
  newApp.use(bodyParser.urlencoded({extended: <span class="hljs-literal">false</span>}))
  newApp.use(bodyParser.json())
  newApp.listen(<span class="hljs-number">3007</span>)
  <span class="hljs-keyword">return</span> newApp
})</code></pre>
				<p>Above example would override default <em>express</em> app initialization. However, should one want to have several different ways to initialize it, <em>injectLaunchCode</em> supports a second argument - <em>name</em>. It must match <em>name</em> which is provided in configuration object when exposing api or using <em>apiMountFactory</em>.</p>
				<p>More information can be found in <em>docs</em> directory inside the <em>api-mount-server</em> package. Also, code suggestions should be available provided a compatible IDE is used (such as <em>VSCode</em>).</p>
				<a href="#protocol" id="protocol" style="color: inherit; text-decoration: none;">
					<h2>Protocol</h2>
				</a>
				<p><em>api-mount-server</em> is designed to expose API from a Node.js server. However, one might want to expose API from a different kind of back-end and still be able to consume it via <em>api-mount-client</em>. In order to do that one has to follow rules explained below. Note that although rules are customizable, below explanation describes default behavior.</p>
				<p>Each API method name should be changed to <em>param-case</em> and exposed as HTTP path.</p>
				<p>In case of successful response, HTTP status should be 200.</p>
				<p>In case of error response (promise rejection or exception), HTTP status should be 500.</p>
				<p>All requests should be of method <em>POST</em>.</p>
				<p>All arguments for API methods should be provided via body JSON which looks like this:</p>
				<pre><code class="language-json">{
  <span class="hljs-attr">&quot;args&quot;</span>: []
}</code></pre>
				<p>Argument values should be listed under <em>args</em> in a JSON format.</p>
				<p>Response should be returned as a JSON object which either carries method return value or error information. As long as response is a valid JSON, there are no other defined constraints.</p>
				<a href="#typescript" id="typescript" style="color: inherit; text-decoration: none;">
					<h2>TypeScript</h2>
				</a>
				<p>When consuming some API exposed by <em>api-mount-server_, it would be convenient to have code suggestions (typings) available. This functionality is currently out of scope for _api-mount</em> but can be achieved with a reasonably minor effort.</p>
				<p>If one is developing using <em>TypeScript_, it allows generating _.d.ts</em> files.</p>
				<p>Let&#39;s say our API is a class defined inside <em>api.ts</em> file. <em>TSC</em> can generate a corresponding <em>api.d.ts</em> file for it. This file could then be shared with <em>client</em> in some way. For example - one could publish a package containing these generated typings every time server gets published.</p>
				<p>When client creates an <em>api</em> object using <em>api-mount-client_, this object/class could then be matched with a generated _d.ts</em>.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-interface">
						<a href="interfaces/iapimountappcache.html" class="tsd-kind-icon">IApi<wbr>Mount<wbr>App<wbr>Cache</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/iapimountapplaunchcache.html" class="tsd-kind-icon">IApi<wbr>Mount<wbr>App<wbr>Launch<wbr>Cache</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/iapimountconfig.html" class="tsd-kind-icon">IApi<wbr>Mount<wbr>Config</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/iapimountlaunchcache.html" class="tsd-kind-icon">IApi<wbr>Mount<wbr>Launch<wbr>Cache</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/isharedapimountconfig.html" class="tsd-kind-icon">IShared<wbr>Api<wbr>Mount<wbr>Config</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#iapimountafterresponse" class="tsd-kind-icon">IApi<wbr>Mount<wbr>After<wbr>Response</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#iapimountapi" class="tsd-kind-icon">IApi<wbr>Mount<wbr>Api</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#iapimountapihandler" class="tsd-kind-icon">IApi<wbr>Mount<wbr>Api<wbr>Handler</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#iapimountbeforeexecution" class="tsd-kind-icon">IApi<wbr>Mount<wbr>Before<wbr>Execution</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#iapimountbeforelisten" class="tsd-kind-icon">IApi<wbr>Mount<wbr>Before<wbr>Listen</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#iapimountbeforeresponse" class="tsd-kind-icon">IApi<wbr>Mount<wbr>Before<wbr>Response</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#iapimountlauncher" class="tsd-kind-icon">IApi<wbr>Mount<wbr>Launcher</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#default_name" class="tsd-kind-icon">DEFAULT_<wbr>NAME</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#default_name_prefix" class="tsd-kind-icon">DEFAULT_<wbr>NAME_<wbr>PREFIX</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#default_port" class="tsd-kind-icon">DEFAULT_<wbr>PORT</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#app" class="tsd-kind-icon">app</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#launched" class="tsd-kind-icon">launched</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#apimountfactory" class="tsd-kind-icon">api<wbr>Mount<wbr>Factory</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#injectlaunchcode" class="tsd-kind-icon">inject<wbr>Launch<wbr>Code</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#performlaunch" class="tsd-kind-icon">perform<wbr>Launch</a>
					</li>
					<li class=" tsd-kind-object-literal">
						<a href="globals.html#launch" class="tsd-kind-icon">launch</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>